#!/usr/bin/env python3
"""Generate or update a module README with an auto-generated section.

This script writes an auto-generated block between markers so future runs can update only that block.
"""
import argparse
from pathlib import Path
from datetime import datetime

MARKER_START = "<!-- AUTO-GENERATED DOC START -->"
MARKER_END = "<!-- AUTO-GENERATED DOC END -->"


def build_auto_content(module: str, module_path: Path) -> str:
    # minimal analysis: list files in module and produce a short template
    files = []
    for p in module_path.rglob("*.dart"):
        rel = p.relative_to(module_path)
        files.append(str(rel))

    now = datetime.utcnow().strftime("%Y-%m-%d")

    content = []
    content.append(MARKER_START)
    content.append(f"\n# {module} — Auto-generated documentation\n")
    content.append(f"**Updated:** {now} (automated)\n")
    content.append("\n## Files scanned\n")
    for f in sorted(files)[:50]:
        content.append(f"- `{f}`")

    content.append("\n## Notes\n- This block is auto-generated by the MCP Documentation Agent.\n- Place human-maintained content outside the auto-generated markers.\n")
    content.append(MARKER_END)
    return "\n".join(content)


def update_readme(module: str, module_path: Path, auto_content: str | None = None):
    readme = module_path / "README.md"
    auto = auto_content or build_auto_content(module, module_path)

    if readme.exists():
        text = readme.read_text(encoding="utf-8")
        if MARKER_START in text and MARKER_END in text:
            before, rest = text.split(MARKER_START, 1)
            _, after = rest.split(MARKER_END, 1)
            new_text = before + auto + after
            readme.write_text(new_text, encoding="utf-8")
            print(f"Updated auto-generated block in {readme}")
            return True
        else:
            # Append auto section
            new_text = text.rstrip() + "\n\n" + auto + "\n"
            readme.write_text(new_text, encoding="utf-8")
            print(f"Appended auto-generated block to {readme}")
            return True
    else:
        # Create a new README with a short human header and auto block
        human_header = f"# {module} (Feature module)\n\n" \
                       "Short description: <write a short description here>.\n\n"
        new_text = human_header + auto + "\n"
        module_path.mkdir(parents=True, exist_ok=True)
        readme.write_text(new_text, encoding="utf-8")
        print(f"Created new README at {readme}")
        return True


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--module", required=True, help="module name under lib/src/modules/")
    parser.add_argument("--repo_root", required=False, help="repo root (optional)")
    parser.add_argument("--auto_content_file", required=False, help="path to file with LLM-generated markdown to insert into auto block")
    args = parser.parse_args()
    module = args.module
    module_path = Path("lib/src/modules") / module
    if not module_path.exists():
        print(f"Module path not found: {module_path}")
        raise SystemExit(1)

    auto_content = None
    if getattr(args, 'auto_content_file', None):
        auto_content = open(args.auto_content_file, 'r', encoding='utf-8').read()

    changed = update_readme(module, module_path, auto_content=auto_content)

    # Update central index entry
    index = Path("docs/features/INDEX.md")
    if index.exists():
        text = index.read_text(encoding="utf-8")
        link = f"- **{module}** — [README](../../lib/src/modules/{module}/README.md)"
        if link in text:
            pass
        else:
            # Try to replace "*No module README yet*" for this module if present
            if f"**{module}**" in text:
                # replace the line
                lines = text.splitlines()
                for i, ln in enumerate(lines):
                    if ln.startswith(f"- **{module}**"):
                        lines[i] = link
                index.write_text("\n".join(lines), encoding="utf-8")
            else:
                # append
                with index.open("a", encoding="utf-8") as fh:
                    fh.write("\n" + link + "\n")
    else:
        # create a minimal index
        index.parent.mkdir(parents=True, exist_ok=True)
        index.write_text(f"# Features Index\n\n- **{module}** — [README](../../lib/src/modules/{module}/README.md)\n", encoding="utf-8")


if __name__ == "__main__":
    main()
